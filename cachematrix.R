## The given script includes two functions namely makeCacheMatrix which creates a matrix. Second function called cacheSolve function either fetches inverse from cache if it's available else it calculates inverse value using "solve" function


#makeCacheMatrix: This function generates matrix. It contains list of 4 functions namely get (to fetch the matrix), set (which set values in matrix), setinverse (which sets values for inverse assuming matrix is invertible) and getinverse (to fetch inverse of the matrix created). Thus, this function is capable to cache its inverse.

makeCacheMatrix <- function(x = matrix()) {
		I <- NULL
        set <- function(y) {
                x <<- y
                I <<- NULL
        }
        get <- function() x
        setinverse <- function(solve)
        I <<- solve
        getinverse <- function() I
        list(set = set, get = get,
             setinverse = setinverse,
             getinverse = getinverse)
}

## cacheSolve firstly checks for whether or not an inverse is already calculated for a given matrix x generated by makeCacheMatrix. If inverse is already available for the given matrix in the cache then it uses the same value else it calculates the inverse using solve function and return the final value. 

cacheSolve <- function(x, ...) {
        ## Return a matrix that is the inverse of 'x'
        I <- makeCacheMatrix(x)$getinverse()
        if(!is.null(I)) {
                message("getting cached data")
                return(I)
        }
        data <- makeCacheMatrix(x)$get()
        I <- solve(data, ...)
        makeCacheMatrix(x)$setinverse(I) 
        I
}

